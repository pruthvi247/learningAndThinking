[ Create efficient Flutter-specific buttons](https://vbacik-10.medium.com/create-efficient-flutter-specific-buttons-aade515ee214)

  [git-lib/usecase/social](https://github.com/VB10/use_case_flutter)
There are three main ideas behind this article:

-   How is the use of adapter patterns similar to the use of social logic features?
-   Exception management: how to make the first code?
-   A pattern-based Atomic widget design is the last step.

The client wants to use Apple, Google, Apple and other social button implementations. This token will be sent to my backend whenever a user completes it successfully. When all operations have been completed, we will reroute the user to the login screen.

I am aware that each provider requires that we perform the identical protocol. The provider will perform basic authentication and return a token response. The button model is also necessary, and I may only define my button properties once for this project.

We first require an adapter in order to use our buttons:

```dart
abstract class SocialAdapter {  
Future<String?> make();  
SocialAdapterModel get model;  
}
```
The method is understandable. Its only mission is to bridge to another provider. When the operation is finished, a response will be returned. We have given a model so that we can use it for design.
```dart
class SocialAdapterModel {  
SocialAdapterModel({  
required this.title,  
required this.color,  
required this.icon,  
});  
  
final String title;  
final Color color;  
final IconData icon;  
}
```
And our architecture is ready. First, I’m going to create an adapter for providers.
```dart
class GoogleAdapter implements SocialAdapter {

@override

Future<String?> make() async {

throw Exception('Google is not supported this device $this');

}

@override

final SocialAdapterModel model = SocialAdapterModel.google();

}

class AppleAdapter implements SocialAdapter {

@override

Future<String?> make() async {

return toString();

}

@override

final SocialAdapterModel model = SocialAdapterModel.apple();

}
```
My adapters are ready. Now it’s time to define the features. I prefer to use the factory method for my buttons, and I can manage it all in one place.

```dart
class SocialAdapterModel {

...

factory SocialAdapterModel.facebook() => SocialAdapterModel(

title: 'Facebbok',

color: const Color(0xFF3B5998),

icon: Icons.facebook,

);

factory SocialAdapterModel.google() => SocialAdapterModel(

title: 'Google',

color: const Color(0xFFDD4B39),

icon: Icons.facebook,

);

factory SocialAdapterModel.apple() => SocialAdapterModel(

title: 'Apple',

color: Colors.black,

icon: Icons.facebook,

);

factory SocialAdapterModel.microsoft() => SocialAdapterModel(

title: 'Microsoft',

color: Colors.black,

icon: Icons.wordpress,

);

...

}
```
Finally, the structure is complete. The next step is to create a generic button widget for this page.

```dart
class SocialButton<T extends SocialAdapter> extends StatelessWidget {

const SocialButton({

super.key,

required this.adapter,

required this.onCompleted,

});

final T adapter;

final void Function(String token) onCompleted;

@override

Widget build(BuildContext context) {

return ElevatedButton.icon(

onPressed: () async => onCompleted.call(await adapter.make.call() ?? ''),

style: ElevatedButton.styleFrom(

backgroundColor: adapter.model.color,

),

icon: Icon(adapter.model.icon),

label: Text(adapter.model.title),

);

}

}
```

As you can see, it’s a really simple widget. Only generic “T” types created from SocialAdapters are used by this. I called the make function to return a response after drawing the widget as it appeared in the class.
![[Pasted image 20230204105215.png]]
As a final step, you call SocialButton with the adapter, and it will do everything automatically for you. Your token will be generated by the provider. Consider this article as an example.
```dart
class SocialView extends StatefulWidget {

const SocialView({super.key});

@override

State<SocialView> createState() => _SocialViewState();

}

class _SocialViewState extends State<SocialView> {

@override

Widget build(BuildContext context) {

return Scaffold(

appBar: AppBar(

title: const Text('Social View'),

),

body: Center(

child: Column(

mainAxisAlignment: MainAxisAlignment.center,

children: [

SocialButton(

adapter: AppleAdapter(),

onCompleted: print,

),

SocialButton(

adapter: GoogleAdapter(),

onCompleted: print,

),

SocialButton(

adapter: FacebookAdapter(),

onCompleted: print,

),

SocialButton(

adapter: MicrosoftAdapter(),

onCompleted: (token) {

if (token.isNullOrEmpty) {

// call your backend

}

},

),

],

),

),

);

}

}
```

### Exception Management
Let’s consider what happens when a user reports a problem to the provider. Probably you are thinking, “I can add a try-catch scope for handling this." Yes, it’s true, but if you add try/catch for every operation, this will create more complexity for exception management.

For a functionality like this, you could create a simple yet universal exception management

```dart
class GlobalException {

static Future<T?> make<T>(AsyncValueGetter<T?> onOperation) async {

try {

final response = await onOperation.call();

if (response == null) {

throw Exception('$T data is null $response');

}

return response;

} catch (e) {

//logger

print('$e $T');

return null;

}

}

}
```
It will look like this if you wish to add this handler to our logic:
```dart
final response2 = await GlobalException.make<String>(adapter.make);  
if (response2 == null || response2.isEmpty) {  
// push to login view  
return;  
}  
  
onCompleted.call(response2);
```
